# Facebook Messenger

## 1. WHY DO WE NEED IT?
- Provides instant messaging service
- Users can use both thier phone or desktop


## 2. REQUIREMENTS AND GOALS OF THE SYSTEM

### Functional Requirement
- 1-1 conversations
- Online/Offline status of the users
- Persistantly store chat history

### Non Functional Requirement
- Real time experience with low latency
- High consistency, same chat history should be in all the devices
- Can trade high availability for consistency although it is desirable


### Extended Requirement
- Group Chats
- Push notifications for offline users

## 3. CAPACITY ESTIMATIONS AND CONSTRAINTS
- Assume we have 500M daily active users
- Each user sends 40 msg a day
- `500M * 40 = 20B` msgs per day

### Storage Estimations
- Assume on average each msg is of 100 bytes
- `100bytes * 20B = 2TB/day` storage requirements
- Let's say we need to handle 5 years of storage then storage req = `2TB * 365 days * 5 ~= 3.6PB`
- Aside from this, we would also need to store metadata of the msgs, users, etc
- We also need to consider data replication

### Bandwidth Estimation
- We need to handle 2TB of data every day, this gives us
- `2TB/(24 * 60 * 60) = 25MB/sec`
- We need this for both upload and download

### High Level Estimation

|                      |                    |
| -------------------- | ------------------ |
| Total Messages       | 20 billion per day |
| Storage for 1 day    | 2TB                |
| Storage for 5 years  | 3.6PB              |
| Incoming Data        | 25MB/sec           |
| Outgoing Data        | 25MB/sec           |

## 4. HIGH LEVEL DESIGN

- We need a chat server which will handle to and fro of the msgs
- The workflow would be like:

- User A sends a msg to User B through chat server
- Chat server receives it and sends the ack to User A that the msg is sent
- Chat server will store the msg in the DB and will send it to User B
- User B would send an ack to the chat server upon receiving the msg
- The chat server would then notify User A about the delivery of the msg

<img src="./Resources/5-1.png">


## 5. DETAILED COMPONENT DESIGN
- We need a server which would handle the following:
    - Deliver outgoing msgs, Receive incoming msgs
    - Store and retrieve msgs from DB
    - keep track of offline/online status of users

### 5.1 Messages Handling
- The user would connect to server to send the msg
- The server has two ways to deliver the msg
    - clients can periodically **pull** new msgs from the server
    - or, the server can **push** the msg as soon as it comes through an open connection

- PULL method:
    - Server would need to keep a track of all the msgs that still needs to be delivered
    - There would be latency in msgs delivery if clients ask for msgs periodically
    - If we make calls frequently, it would decrease the latency but there will be a lot of empty responses, wasting resources

- PUSH method:
    - We will have an active connection
    - Low latency as the msgs will be pushed to clients as soon as it is sent
    - No need to keep a track of undelivered msgs
    - Can do this by long-polling or websockets
    - We would have a hash table with key as user_id and value as connection object, when a msg needs to be transfered to a user, we will find the connection through this table

- If server receives a msg and the user is offline, it can notify the server about failed delivery, then the client can retry. We can implement retries at server level too

- If we `500M` active users at any time, if a server can hold `50K` concurrent connections, we would need `10K` servers

- Following steps takes place in delivery:
    - The user sends a request to send a msg
    - There will load balancers in front of chat servers
    - Load balancer will pass the request to the user mapped chat server
    - This chat server will find the server maintaining the connection with the receipent user
    - Chat server will pass the request to that server, storing the msg in the db in the background


- There will be senarios when msg sequence for two users would be different in their chat
- Keep a sequence number with every msg for each client
- This will keep ensure that atleast the ordering is same for all his/her devices

### 5.2 Storing and Retrieving the messages from DB
- We have two options:
    - Create a seprate thread and work with DB
    - Send an async call to the DB
- Things to keep in mind:
    - Efficiently work with the DB connection pool
    - How to handle retiries
    - How to handle logging of msgs which fail even after certain retires
    - How to retry logged msgs once the errors are fixed
- Since we need to store a small amount of data very frequently and fetch range of records quickly
    - Working with MySQL is inefficient
    - Wide column DB (Like HBase) solves both problem
    - HBase is a key val no sql db, modeled after BigTable
    - Stores multiple columns against a key
    - Groups new data together in a memory buffer and dumps in the disk when memory fills up
    - Can be used to fetch rows by keys and get range of data
    

### 5.3 Managing user status
- We can get the status by the connection we are maintaining for each user
- When a user comes online, the client can fetch the status of all the friends
- Can periodically fetch the status of the users currently in viewport
- If a msg delivery fails, we can update the status to offline
- When a user comes online, we can broadcast the status with a delay to see if the user doesn't go offline immediately
- We can fetch the the user status whenever a new chat starts


## 6. DATA PARTITIONING AND REPLICATION
- We can make shards on the basis of user_id
- Msg of one user will remain in a single shard
- If a shard is of 4TB, we would require 3.6PB/4TB = 1000 shards
- we can have a hash function which will give shard id of the a user by hash(user_id)%1000
- By doing this, we can access a user chat pretty fast
- We can add more physical servers according to the need
- We need to replicate msgs to different servers so that recovery is possible in a crash

## 7. CACHE
- We can cache a few messages (last 15) for recent conversations which are visible in client viewport (lets say 5)
- Cache for a user will recide in a single machine

## 8. LOAD BALANCING
- We need load balancers in front of our chat servers
- They will map each user_id to a server that holds the connection for that user
- Similarly we need load balancer for our cache servers

## 9. EXTENDED REQUIREMENTS
- Group Chats
    - Can be identified by group_id
    - This group_id can be used to identify the group in which we will have all the user_ids in that group
    - We can iterate over those user_ids to get the servers holding the connections
    - We can partition db based on group_id in a separate table
- Push notifications
    - This will enable us to send msgs to offline users
    - We will have a separate notification server which will send msg to client's push notification server
    - The client notify server will then send the msg to the actual device